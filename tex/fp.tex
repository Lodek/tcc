\subsection{Programação Funcional}

Primeiro, vejamos a historia das linguagens imperativas e seu desenvolvimento.
Usaremos isso para contrastar com a progressão das linguagens funcionais.

%Origens, lambda calculus e a diferente evoluçao.
A maquina de Turing foi muito importante para a evolução dos computadores, um modelo idealizado capaz de resolver vários problemas a partir de instruções simples.
Usando o modelo da maquina de Turing, os processadores foram projetados para mimicar essas operações, introduzindo instruções leitura, comparação e jump.
Como consequencia, vieram as linguagens assembly, uma especie de dicionario que permite programar usando palavras ao invés de códigos de instruções.
Embora assembly tenha facilitado muito a programação, ela ainda é muito próximo do hardware e extremamente trabalhoso de definir os passos para escrever um programa.
Para resolver isso veio a programação estruturada, que introduziu os ifs, whiles e fors.
O processo de design de linguagens foi longo, foram diversas abstrações, construidas de maneira iterativa.
Atualmente o paradigma considerado mais alto nível e muito usado é a orientação a objetos.
Perceba que as linguagens imperativas foram construídas a partir de uma construção simples e que o resultado foi um processo longo para tornar esse modelo mais intuitivo aos humanos, especialmente com a programação orientada a objetos.
%Find citations

Enquanto as linguagens imperativas tem como descendente comum a maquina de Turing, a programação funcional tem origem em um outro modelo mátematico da computação, o calculo lambda.
O calculo lambda é um outro modelo matemático, que ao invés de focar em instruções, foca na construção e aplicação de funções.
A introdução do calculo lambda foge do escopo desse trabalho, porém o mesmo é a origem das linguagens funcional.
Embora a maquina de Turing e o calculo lambda seja ideologicamente diferentes, foi comprovado através da hipostose de Alan Turin and Wistom Churchill que os dois são equivalentes.
Logo, os problemas resolvidos usando linguagens imperativas podem também ser resolvidos pelas linguagens funcional, e vice-versa.
O fato desses dois paradigmas terem uma origem extremamente diferente é ótimo para ilustrar o motivo pelo qual muitos programadores tem dificuldade com linguagens funcional.
Isso se deve ao fato delas serem construídas a partir de conceitos extremamente diferentes, porém ambos tem o mesmo objetivo: resolver problemas computacional.

Segundo \cite{Bird},
\begin{quotation}
"Programção funcional é: um método para construção de programas que enfatiza funções e suas aplicações ao invéz de commandos e suas execuções; programação funcional faz uso de notações matemática simples que permite que problemas sejam descritos de maneira clara e concisa. [...]".
\end{quotation}
A programação imperativa foca em passos para resolver um problema, cada passo desse pode ser traduzido de maneira rasoavelmente direta em instruções de uma CPU.
Isso faz com que o procedimeto escrito imperativemente reflita muito mais a máquina do que ao homem.
O paradigma funcional tira o foco nos passos individuais para solucionar o problema e enfatiza uma estrutura para resolver o problema.

Em seguida serão abordados aspectos mais técnicos da programação funcional.

\subsubsection{Imutabilidade}

Um conceito comumente encontrado na programação funcional é a imutabilidade.
Uma linguagem imutavel trata as variaveis de um programa similar à matemática, tal que o valor de uma variavel so pode ser definido no momento de sua inicializacão.
Isso é equivalente a definir todas as variaveis como final ou constante, dependendo da linguagem imperativa.

A imutabilidade é desejavel pois permite racicionar sobre o programa de maneira mais facil, uma funcão nunca tera um efeito colateral.
Sabemos com certeza que um valor não ira mudar apos ter sido inicializado.
Isso serve como uma especie de invariante que permite racionalizar sobre o programa.
Isso evita diversos problemas comuns que ocorre quando compartilhamos objetos, desde falta de atenção pela parte do programador até condições de corrida impostas pelo algoritimo.

Essa restrição é interessante pois altera muito a maneira como algoritimos são escritos.
A ausencia da mutabilidade implica que não existe variaveis acumuladoras nem contadores.
Sem contadores, a alternativa para repetir um bloco de código por n vezes passa a ser a recursão.
A recursão é extremamente utilizada na programação funcional pois ela permite que uma funcão realize uma computação repetitiva, sem mutar valores.

\subsubsection{Funções como um cidadão de primeira classe}

Na programação, os tipos primitivos de uma linguagem são os blocos a partir do qual é possível construir estruturas complexas.
Os tipos primitivos podem ser armazenados em uma variável, passados para uma função, e normalmente existem operadores que opera sobre esses tipos.
Para a programação funcional, uma função é um tipo de dado primitivo, isso significa que é possível declarar e armazenar uma função em uma variavel, passar uma função para uma função e receber uma função como retorna de uma função.

Na programação funcional, usar uma função como um tipo de dado é uma pratica essencial para criar abstrações.
Uma função que recebe uma função como argumento é chamada de função de ordem superior.
Hughes \cite{whyfpm} argumenta que a funções de ordem superior são essencial pois elas permitem uma melhor reusabilidade de código.
Essa pratica é tão comum e poderoza que diversas linguagens populares, tal como JavaScript e Python, possuem esses tipos de função no seu core, tais como as funções: map, filter e reduce.
%In video, explain what each functino does

E de fato, um exemplo de uma abstração muito poderoza é a função reduce, ou como é chamada em Haskell, fold.
Essa função é normalmente utilizada para iterar sobre uma lista de valores e produzir um novo valor.
Porém, essa abstração em especifico é extremamente poderoza, em \cite{graham} o autor argumenta a favor de sua expressividade.

As três funções mencionadas são exemplos de funções de ordem superior reutilizaveis e expressivas.
É interessante notar que uma função de ordem superior, muitas vezes, pode ser extendida para aceitar diferentes tipos.
Em Haskell, existe varios tipos de dados que aceitam a função fold, não so listas, e em \cite{whyfpm} é argumentado que cada tipo de dados definida deve tambem implementar funções de ordem superior para operar sobre essa estrutura.

%For video, talk about functions that return functions
%Adding behavior before/after method, python decorators and aspects

Em conclusão, funções como um cidadão de primeira classe permite tratar funções como valores e realizar tranformações sobre elas de maneira transparente.
Esse conceito permite que funções de ordem superior existam na linguagem e foi argumentado a favor do poder de abstração dessa prática.

\subsubsection{Indo além}

Existem vários outros importantes conceitos sobre programação funcional, porém por motivos de breviedade eles não serão comentados nesse artigo mas sim, mencionados e direcionados para outras literaturas.

Um tópico polarizador em programação funcional é o assunto de \emph{laziness} e \emph{eager}, referindo a quando um valor será computado.
Existem vantagens e desvantagens para ambos; laziness é interessante por melhor performance em alguns casos, porém dificulta raciocinar sobre o programa.
É importante mencionar que em \cite{whyfpm}, o autor argumenta que laziness é fundamental para abstrair programas funcionais.

Outro ponto importante é sobre tipos de dados algebricos.
Tipos de dados algebricos permitem a implementação de tipos de dados recurssivos.
Em Haskell, uma lista é um tipo de dado recurssivo, com dois construtores.
Tipos de dados algebricos possibilitam \emph{pattern matching}, uma maneira sucinta de verificar a estrutura de um dado.
Uma boa introdução pode ser encontrada em \cite{lipovaca} e \cite{rust}.

Por último, é importante mencionar alguns assuntos que surgiram no Haskell, dentre eles type classes e monads.
Type classes foi a solução implementada em Haskell para um problema muito comum em linguagens de programação: override operadores \cite{haskell-ivory}.
Monads é praticamente uma buzz-word em programação funcional, especialmente na comunidade Haskell.
Sobre monads, é interessante mencionar que eles foram a solução para um grande problema que Haskell teve: como ser uma linguagem pura porém com efeitos colaterais \cite{haskell-ivory}.

\subsubsection{Conclusão}

Programação funcional é um tópico extenso com uma historia rica e de maneira nenhuma seria introduzir tudo sobre nesse artigo.
Foi visto como as origens das linguagens funcionais diferem das linguagens imperativas, sendo baseadas no calculo lambda.
Em seguida foi introduzido dois conceitos importantes: imutabilidade e função como um cidadão de primeira classe.
Foi argumentado a favor da modularidade e abstração que esses conceitos introduzem.
Por fim, foram comentado sobre diferentes conceitos importantes para as linguagens funcionais, porém que fogem do escopo desse trabalho.

\input{tex/metodologia}
