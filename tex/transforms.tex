\subsubsection{Funções para resolver problemas}

Como visto anteriormente, a programação funcional propoem que problemas computacionais sejam resolvidos de maneira mais declarativa.
O foco muda de "quais passos é preciso para resolver esse problema" para "quais transformações aplicar nas minhas entradas para produzir a saída".
Um problema muito interessante para abordarmos a ideia de "transformações" pode ser o algorítmo de \emph{merge sort}.

Para exemplificar essa idea considere o seguinte problema.
Dado uma lista de nomes, com nome, nome do meio e sobrenomes, crie uma lista com todas as combinações de primeiro nome e ultímo nome, ignorando nomes do meio e cuja e só aceitar as combinações cuja soma do primeiro nome e ultimo nome não excede 15 carácteres (incluindo o espaço).
Para isso, ao invez de analisar o processo para processar esses dados uma boa ideia é pensar em como manipular os dados para se obter o resultado esperado.
Para esse problema, sugere-se a seguinte solução:

1 - Separar cada nome da lista de nomes nos espaços e armazenar os nomes uma lista. 
2 - Filtrar listas que só possuem um elemento (somente um nome).
3 - Filtrar listas e remover nomes do meio.
4 - Criar uma lista de nomes e uma lista sobrenomes.
5 - Realizar o produto cartesiano sobre essa lista e gerar uma lista de tuplas.
6 - Tranformar tuplas em strings fazendo a concatenação do primeiro nome e do sobrenome.

Percebe-se que cada passo acima realiza uma única ação, sendo ela simples e clara e é interessante modelar cada um desses passos como uma função.
Na linguagem Haskell o tipos dos argumentos e do retorno de uma função é dado pela notação nomeDaFuncao :: arg1 -> arg2 -> ... -> retorno, onde arg1 e arg2 definem os tipos dos argumentos \cite{lipovaca}.
Para identificar listas em Haskell é usado o símbolo [], ou seja [Char] indica uma lista de carácteres e tuplas são indicatas com () onde (String, String) indica uma tupla com dois elementos, ambos strings.
Podemos agora reescrever o problema acima definindo todas as funções que serão utilizadas.

Primeiramente definiremos o problema enunciado como uma função usando a notação introduzida.
O problema inicial é uma função $combinarNomes :: [String] -> [String]$ , ou seja uma função que recebe uma lista de Strings e retorna uma lista de Strings.
Em seguida, iremos declarar a função que representa cada passo acima.

1 - separarNomes :: [String] -> [[String]]
2 - tirarIncompleto :: [[String]] -> [[String]]
3 - removerSobrenomes :: [[String]] -> [[String]]
4 - gerarNomesESobrenomes :: [[String]] -> ([String], [String])
5 - gerarCombinacoes :: ([String], [String]) -> [(String, String)]
6 - concatenarNomes :: [(String, String)] -> [String]

