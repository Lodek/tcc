\section{EXPRESSÕES REGULARES E PROGRAMAÇÃO FUNCIONAL}
Como foi abordado na introdução, esse trabalho une dois temas: expressões regulares e programação funcional.
Esses temas serão, primeiramente, discutidos separadamente, e em seguida será feito uma previa de como será feita a construção do motor de processamento de expressões regulares.

\subsection{Introdução as expressões regulares}

Expressões regulares, tambem conhecidas como \emph{regex} (da junção do nome em inglês, \emph{regular expression}) são utilizadas para realizar buscas complexas sobre strings.
Para Cox,
"expressões regulares são uma notação que descreve um conjunto de strings.
Quando alguma string está no conjunto descrito pela expressão regular, pode-se dizer que essa expressão regular corresponde a esse string." \cite{cox}.

As regexes são utilizadas frequentemente, tanto para extrair informações que seguem um padrão ou para realizar buscas mais flexíveis ou parciais.
Como exemplo, suponha o problema de extrair todas os strings que correspondem a um horario em um texto.
A escrita de um horario segue uma estrutura padrão, HH:MM:SS onde HH delimita as horas, MM delimita os minutos e SS delimita os segundos.
Sem ter que construir todas as possíveis combinações de horas que seguem esse formato, uma simples varredura de texto é incapaz de extrair essa informação.
Esse problema pode ser resolvido tranquilamente usando regexes.

Uma expressão regular que realiza esta busca é,
\begin{equation}
  [0-9]{2}:[0-9]{2}:[0-9]{2} .
\end{equation}

Em palavras, os símbolos [0-9] representa qualquer carácter numerico entre 0 e 9.
O token {2} indica uma repetição, sendo equivalente à regex [0-9][0-9], ou seja dois carácteres numericos.
O carácter : é interpretado como o símbolo dois pontos literal.
Fazendo a união, a regex acima equivale a qualquer string que tenha o formato DD:DD:DD onde D indica qualquer digito de 0-9.
Podemos ver que esse formato é exatamente o formato definido anteriormente.

É importante ressaltar que existem inumeras variações e implementações de regexes, onde existem diferentes meta-characteres para descrever operações.
Em \cite{mastering}, o autor discute as diferenças em regex entre as linguagens: PHP, .NET, Java e Perl.
Na documentação oficial da linguagem Python \cite{python-re} é dito que o dialeto usado é basedo nas expressões regulares da linguagem Perl com alguns adicionais.
Usuários UNIX também estão familiarizados com os \emph{wildcards} presentes nos shells.
Em resumo, existem vários dialetos porém os o objetivo das regexes não se altera, buscar por padrões.
A regex acima e todas as regexes subsequentes nesse texto serão escritos no dialeto da linguagem Perl. 

\subsection{Programação Funcional}

Essa seção aborda o tópico sobre programação funcional e suas caracteristicas de maneira resumida.
Há muito a se falar sobre esse assunto pois ele é extensso e tem uma longa história.
Para abordar a programação funcional será tomado um foco que toma como base a computação.

De maneira geral, programas de computadores existem para resolver problemas computacionais.
Segundo \cite{matrix} um problema computacional é
" [...] uma especificação de entrada-saída que um procedimento tenha que satisfazer."
e um procedimento é
"[...] uma descrição precisa de uma computação; ele aceita entradas (chamadas de argumentos) e produz uma saída (chamado de valor de retorno).".
Ou seja, independente do paradigma utilizado para resolver o problema (funcional ou imperativa), ambos são capazes de definir um procedimento para um problema computacional, a grande diferença está em como esse procedimento é definido.

Segundo \cite{Bird},
"programção funcional é: um método para construção de programas que enfatiza funções e suas aplicações ao invéz de commandos e suas execuções; programação funcional faz uso de notações matemática simples que permite que problemas sejam descritos de maneira clara e concisa. [...]".
A programação imperativa foca em passos para resolver um problema, cada passo desse pode ser traduzido de maneira rasoavelmente direta em instruções de uma CPU.
Isso faz com que o procedimeto escrito imperativemente reflita muito mais a máquina do que ao homem.
O paradigma funcional tira o foco nos passos individuais para solucionar o problema e enfatiza uma estrutura para resolver o problema.

Em seguida serão abordados aspectos mais técnicos da programação funcional.

\subsubsection{Funções para resolver problemas}

Como visto anteriormente, a programação funcional propoem que problemas computacionais sejam resolvidos de maneira mais declarativa.
O foco muda de "quais passos é preciso para resolver esse problema" para "quais transformações aplicar nas minhas entradas para produzir a saída".
Um problema muito interessante para abordarmos a ideia de "transformações" pode ser o algorítmo de \emph{merge sort}.

Para exemplificar essa idea considere o seguinte problema.
Dado uma lista de nomes, com nome, nome do meio e sobrenomes, crie uma lista com todas as combinações de primeiro nome e ultímo nome, ignorando nomes do meio e cuja e só aceitar as combinações cuja soma do primeiro nome e ultimo nome não excede 15 carácteres (incluindo o espaço).
Para isso, ao invez de analisar o processo para processar esses dados uma boa ideia é pensar em como manipular os dados para se obter o resultado esperado.
Para esse problema, sugere-se a seguinte solução:

1 - Separar cada nome da lista de nomes nos espaços e armazenar os nomes uma lista. 
2 - Filtrar listas que só possuem um elemento (somente um nome).
3 - Filtrar listas e remover nomes do meio.
4 - Criar uma lista de nomes e uma lista sobrenomes.
5 - Realizar o produto cartesiano sobre essa lista e gerar uma lista de tuplas.
6 - Tranformar tuplas em strings fazendo a concatenação do primeiro nome e do sobrenome.

Percebe-se que cada passo acima realiza uma única ação, sendo ela simples e clara e é interessante modelar cada um desses passos como uma função.
Na linguagem Haskell o tipos dos argumentos e do retorno de uma função é dado pela notação nomeDaFuncao :: arg1 -> arg2 -> ... -> retorno, onde arg1 e arg2 definem os tipos dos argumentos \cite{lipovaca}.
Para identificar listas em Haskell é usado o símbolo [], ou seja [Char] indica uma lista de carácteres e tuplas são indicatas com () onde (String, String) indica uma tupla com dois elementos, ambos strings.
Podemos agora reescrever o problema acima definindo todas as funções que serão utilizadas.

Primeiramente definiremos o problema enunciado como uma função usando a notação introduzida.
O problema inicial é uma função $combinarNomes :: [String] -> [String]$ , ou seja uma função que recebe uma lista de Strings e retorna uma lista de Strings.
Em seguida, iremos declarar a função que representa cada passo acima.

1 - separarNomes :: [String] -> [[String]]
2 - tirarIncompleto :: [[String]] -> [[String]]
3 - removerSobrenomes :: [[String]] -> [[String]]
4 - gerarNomesESobrenomes :: [[String]] -> ([String], [String])
5 - gerarCombinacoes :: ([String], [String]) -> [(String, String)]
6 - concatenarNomes :: [(String, String)] -> [String]

Segundo \cite{lipovaca} a assinatura de uma função em Haskell combinado com um nome descritivo diz muito sobre a função e de fato, dados os nomes e sua assinatura, pode-se facilmente deduzir o que cada função está fazendo.
O objetivo dessa seção foi dar um exmplo alto nível de como é resolvido um problema de maneira funcional.


\subsection{Algoritimos de regex}


\subsection{METODOLOGIA}

Utilizando os algoritimos abordados na secao de algoritimos, sera criado um modulo escrito funcionalmente em Haskell para realizar a pesquisa de regexes em um texto.

Tenho duvida a respieto dessa secao. O que faz parte do escopo de metodologia?
Praticas de desenvolvimento aplicadas como testes unitarios?

Acredito que a maior parte do conteudo abordado aqui seja estabelecido apos a escolha do algoritmo(s) de regex a serem implementados.

A definicao do dialeto da regex, junto dos simbolos especiais, flags e etc deve ser feita nessa secao ou na fundamentacao teorica?


