\section{EXPRESSÕES REGULARES E PROGRAMAÇÃO FUNCIONAL}
Como foi abordado na introdução, esse trabalho une dois temas: expressões regulares e programação funcional.
Esses temas serão, primeiramente, discutidos separadamente, e em seguida será feito uma previa de como será feita a construção do motor de processamento de expressões regulares.

\subsection{Expressão Regular}

\subsubsection{Introdução as expressões regulares}

Expressões regulares, tambem conhecidas como \emph{regex} (da junção do nome em inglês, \emph{regular expression}) são utilizadas para realizar buscas complexas sobre strings.
Para Cox, "expressões regulares são uma notação que descreve um conjunto de strings. Quando alguma string está no conjunto descrito pela expressão regular, pode-se dizer que essa expressão regular corresponde a esse string." \cite{cox}.

As regexes são utilizadas frequentemente, tanto para extrair informações que seguem um padrão ou para realizar buscas mais flexíveis e parciais.
Como exemplo, suponha o problema de extrair todas os strings que correspondem a um horario em um texto.
A escrita de um horario segue uma estrutura padrão, HH:MM:SS onde HH delimita o horario, MM delimita os minutos e SS delimita os segundos.
Sem ter que construir todas as possíveis combinações de horas que seguem esse formato, uma simples varredura de texto é incapaz de extrair essa informação.
Esse problema pode ser resolvido tranquilamente usando regexes.

Uma expressão regular que pode ser utilizada para resolver esse problema é,
\begin{equation}
  [0-9]{2}:[0-9]{2}:[0-9]{2} .
\end{equation}

Em palavras, os os símbolos [0-9] representa qualquer carácter numerico entre 0 e 9.
O token {2} indica uma repetição, sendo equivalente à regex [0-9][0-9], ou seja dois carácteres numericos.
O carácter : é interpretado como o símbolo dois pontos literal.
Fazendo a união, a regex acima equivale a qualquer string que tenha o formato DD:DD:DD onde D indica qualquer digito de 0-9.
Podemos ver que esse formato é exatamente o formato definido anteriormente.

É importante ressaltar que existem inumeras variações e implementações de regexes, onde existem diferentes meta-characteres para descrever operações.
Em \cite{mastering}, o autor discute as diferenças em regex entre as linguagens: PHP, .NET, Java e Perl.
Na documentação oficial da linguagem Python \cite{python-re} é dito que o dialeto usado é basedo nas expressões regulares da linguagem Perl com alguns adicionais.
Usuários UNIX também estão familiarizados com os \emph{wildcards} presentes nos shells.
Em resumo, existe uma grande de dialetos porém os o objetivo das regexes não se altera.
A regex acima e todas as regexes subsequentes nesse texto serão escritos no dialeto da linguagem Perl. 


\subsubsection{Programacao Funcional}

Os conceitos de programacao funcional surgiram junto do calculo lambda, inventado por Alonzo Curch.
% TODO: Expandir, falar sobre lambda calculus, funcoes.
Embora existam varias linguagens funcionais (ML, Lisp, Rackett, Haskell), todas elas compartilham essa origem.
Tal como em programacao imperativa que diferencia linguagens entre procedural e orientada a objetos, existem diferencas entre as linguagens funcionais, mas primeiramente, o que eh programacao funcional.
Segundo \cite{Bird}, ''programcao funcional eh: um metodo para construcao de programas que enfatiza funcoes e suas aplicacoes ao invez de commandos e suas execucoes; programacao funcional faz uso de notacao matematica simples que permite que problemas sejam descritos de maneira clara e concisa. [...]''.
% TODO: Referenciar Simon Thompson e Graham Hutton.

Esse trabalho foca na linguagem Haskell como fonte de exemplos para o paradigma funcional.
Haskell, como toda linguagem, possui suas proprias particularidades, porem grande partes dos conceitos apresentados sera geral para linguagens funcionais.

Haskell faz parte do conjunto de linguagens conhecidas como ''linguagens funcionais puras''.
Uma linguagem pura permite a \emph{definicao} de simbolos uma unica vez, exemplo, ao definir ''let a = 4'' em um programa, tentar mudar o valor da variavel ''a'' resulta em um error.
O valor de um simbolo nao pode mudar durante a execucao do programa, de certa forma isso eh equivalente as keywords ''final'' do java e ''const'' da linguagem C.
Embora nao poder atualizar o valor de uma variavel soe como uma grande desvantagem, isso permite o que pode ser chamado de ''funcoes sem efeito-colateral''.
Isso significa que uma funcao jamais ira alterar o estado do programa fora dela, toda vez que uma funcao for chamada com os mesmos atributos, ela ira retornar o mesmo valor, isso nao eh o caso em linguagens orientadas a objeto, por exemplo, onde metodos alteram o estado do objeto (setters).
O conceito de funcoes sem efeito colateral eh uma vantagem pois isso facilita o entendimento do programador sobre a sequencia de eventos do programa, nao existe preucupacao de que uma funcao altere alguma variavel global ou o estado de um objeto.
Lipovaca expressa o conceito de linguagem funcional pura de maneira instrutiva, ele diz que:
''Embora isso parece limitante quando voce esta vindo do mundo imperativo, nos vimos que isso eh algo realmente legal. Em uma linguagem imperativa voce nao tem garantia de que uma simples funcao que deveria somente processar alguns numeros nao ira queimar sua casa, sequestrar seu cachorro e riscar seu carro com uma batata enquanto processa aqueles numeros.''.

Como nao podemos alterar o estado de uma variavel em um programa funcional, isso nos forca a procurar diferentes maneiras de resolver problemas computacionais.
Um exemplo classico disso eh o problema de calcular o fatorial de um numero.
O fatorial de n (n!) eh definido como $ n! = (1)*(2)*...*(n-1)*(n)$.
Em uma linguagem imperativa, esse problema pode ser resolvido com um for, uma variavel acumuladora e uma variavel contadora; como nao podemos mutar o valor de definicoes em linguagens funcionais, podemos fazer usso de recurssao.

O programa abaixo define uma funcao ''factorial'' que recebe um valor do tipo int retorna um de valor int.
A funcao ''factorial'' retorna o valor 1 quando seu argumento eh 0 e retorna o valor n * (n-1)! para qualquer outro valor.
Essas curiosa sintaxe faz uso de um construtor muti util do Haskell chamado de \emph{patten matching}.
Segundo \ref{lipovaca}, ''pattern matching consiste de especificar padroes para o qual algum dado deve tomar forma, verificar se o dado acorda com esses padroes'', eh possivel definir varios padroes para uma unica funcao.
Padroes sao executados de cima para baixo e por isso padroes mais gerais (dao match em um maior numero de situacoes) devem ser posicionados por ultimo.

factorial :: Int -> Int
factorial 1 = 1
factorial n = n * factorial (n-1)

Tipos de dados diferentes possuem diferentes possibilidades de pattern matching.
Em Haskell, valores contidos dentro de colchetes ''[]'' define uma lista, e o padrao (x:xs) define que x eh o primeiro elemento da lista e xs o restante da lista.
Por exemplo, dado a lista [1,2,3] os valores de (x:xs) em um pattern matching tera o valor de x = 1 e xs = [2,3].
Usando esse construtor, podemos definir a funcao sum que soma todos os numero em uma lista.

sum :: [Int] -> Int
sum [] = 0
sum (x:xs) = x + sum xs

O codigo acima define uma funcao sum que recebe uma lista de ints (''[Int]'') e retorna um int, a funcao sum faz uso de dois pattern matchings.
O primeiro padrao ''[]'' faz match com uma lista vazia, o valor da funcao sum para a lista vazia eh definido como o valor 0.
Caso a lista nao seja vazia, o segundo padrao eh executado, e para aquele caso a soma de uma lista eh definida como o primeiro elemento mais a soma do restante da lista.
Novamente, isso eh uma funcao que faz uso de recursao para resolver o problema computacional.
A funcao sum chama a ela mesma ate o valor de xs ser a lista vazia, para o qual definimos que isso seria igual a $0$.
Caso omitissimos o primeiro padrao, a funcao iria chamar a ela mesma indefinitvamente.
Pattern matching eh muito util em funcoes recursivas pois nos permite definir a condicao de saida da recurssao.

\subsubsection{Algoritimos de regex}

Nessa secao sera abordado um pouco sobre maquinas de estado, como elas podem ser usadas para representar expressoes regulares.
Talvez abordar a diferenca entre maquinas deterministicas e nao deterministicas, e como uma maquina nao deterministica pode ser transformada em deterministica.

Ainda estou em duvida qual algoritimo sera utilizado para a construcao da biblioteca, irei pesquisar mais sobre isso.

\subsection{METODOLOGIA}

Utilizando os algoritimos abordados na secao de algoritimos, sera criado um modulo escrito funcionalmente em Haskell para realizar a pesquisa de regexes em um texto.

Tenho duvida a respieto dessa secao. O que faz parte do escopo de metodologia?
Praticas de desenvolvimento aplicadas como testes unitarios?

Acredito que a maior parte do conteudo abordado aqui seja estabelecido apos a escolha do algoritmo(s) de regex a serem implementados.

A definicao do dialeto da regex, junto dos simbolos especiais, flags e etc deve ser feita nessa secao ou na fundamentacao teorica?


