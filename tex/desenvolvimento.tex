\section{EXPRESSÕES REGULARES E PROGRAMAÇÃO FUNCIONAL}
Como foi abordado na introdução, esse trabalho une dois temas: expressões regulares e programação funcional.
Esses temas serão, primeiramente, discutidos separadamente, e em seguida será feito uma previa de como será feita a construção do motor de processamento de expressões regulares.
\subsection{Expressão Regular}

\subsubsection{Introdução as expressões regulares}

Expressões regulares, tambem conhecidas como \emph{regex} (da junção do nome em inglês, \emph{regular expression}) são utilizadas para realizar buscas complexas sobre strings.
Para Cox,
"expressões regulares são uma notação que descreve um conjunto de strings.
Quando alguma string está no conjunto descrito pela expressão regular, pode-se dizer que essa expressão regular corresponde a esse string." \cite{cox}.

As regexes são utilizadas frequentemente, tanto para extrair informações que seguem um padrão ou para realizar buscas mais flexíveis ou parciais.
Como exemplo, suponha o problema de extrair todas os strings que correspondem a um horario em um texto.
A escrita de um horario segue uma estrutura padrão, HH:MM:SS onde HH delimita as horas, MM delimita os minutos e SS delimita os segundos.
Sem ter que construir todas as possíveis combinações de horas que seguem esse formato, uma simples varredura de texto é incapaz de extrair essa informação.
Esse problema pode ser resolvido tranquilamente usando regexes.

Uma expressão regular que realiza esta busca é,
\begin{equation}
  [0-9]{2}:[0-9]{2}:[0-9]{2} .
\end{equation}

Em palavras, os símbolos [0-9] representa qualquer carácter numerico entre 0 e 9.
O token {2} indica uma repetição, sendo equivalente à regex [0-9][0-9], ou seja dois carácteres numericos.
O carácter : é interpretado como o símbolo dois pontos literal.
Fazendo a união, a regex acima equivale a qualquer string que tenha o formato DD:DD:DD onde D indica qualquer digito de 0-9.
Podemos ver que esse formato é exatamente o formato definido anteriormente.

É importante ressaltar que existem inumeras variações e implementações de regexes, onde existem diferentes meta-characteres para descrever operações.
Em \cite{mastering}, o autor discute as diferenças em regex entre as linguagens: PHP, .NET, Java e Perl.
Na documentação oficial da linguagem Python \cite{python-re} é dito que o dialeto usado é basedo nas expressões regulares da linguagem Perl com alguns adicionais.
Usuários UNIX também estão familiarizados com os \emph{wildcards} presentes nos shells.
Em resumo, existem vários dialetos porém os o objetivo das regexes não se altera, buscar por padrões.
A regex acima e todas as regexes subsequentes nesse texto serão escritos no dialeto da linguagem Perl. 

\subsection{Programação Funcional}

Essa seção aborda o tópico sobre programação funcional e suas caracteristicas de maneira resumida.
Há muito a se falar sobre esse assunto pois ele é extensso e tem uma longa história.
Para abordar a programação funcional será tomado um foco que toma como base a computação.

De maneira geral, programas de computadores existem para resolver problemas computacionais.
Segundo \cite{matrix} um problema computacional é
" [...] uma especificação de entrada-saída que um procedimento tenha que satisfazer."
e um procedimento é
"[...] uma descrição precisa de uma computação; ele aceita entradas (chamadas de argumentos) e produz uma saída (chamado de valor de retorno).".
Ou seja, independente do paradigma utilizado para resolver o problema (funcional ou imperativa), ambos são capazes de definir um procedimento para um problema computacional, a grande diferença está em como esse procedimento é definido.

Segundo \cite{Bird},
"programção funcional é: um método para construção de programas que enfatiza funções e suas aplicações ao invéz de commandos e suas execuções; programação funcional faz uso de notações matemática simples que permite que problemas sejam descritos de maneira clara e concisa. [...]".
A programação imperativa foca em passos para resolver um problema, cada passo desse pode ser traduzido de maneira rasoavelmente direta em instruções de uma CPU.
Isso faz com que o procedimeto escrito imperativemente reflita muito mais a máquina do que ao homem.
O paradigma funcional tira o foco nos passos individuais para solucionar o problema e enfatiza uma estrutura para resolver o problema.

Em seguida serão abordados aspectos mais técnicos da programação funcional.

\subsubsection{Funções para resolver problemas}

Como visto anteriormente, a programação funcional propoem que problemas computacionais sejam resolvidos de maneira mais declarativa.
O foco muda de "quais passos é preciso para resolver esse problema" para "quais transformações aplicar nas minhas entradas para produzir a saída".
Um problema muito interessante para abordarmos a ideia de "transformações" pode ser o algorítmo de \emph{merge sort}.

Para exemplificar essa idea considere o seguinte problema.
Dado uma lista de nomes, com nome, nome do meio e sobrenomes, crie uma lista com todas as combinações de primeiro nome e ultímo nome, ignorando nomes do meio e cuja e só aceitar as combinações cuja soma do primeiro nome e ultimo nome não excede 15 carácteres (incluindo o espaço).
Para isso, ao invez de analisar o processo para processar esses dados uma boa ideia é pensar em como manipular os dados para se obter o resultado esperado.
Para esse problema, sugere-se a seguinte solução:

1 - Separar cada nome da lista de nomes nos espaços e armazenar os nomes uma lista. 
2 - Filtrar listas que só possuem um elemento (somente um nome).
3 - Filtrar listas e remover nomes do meio.
4 - Criar uma lista de nomes e uma lista sobrenomes.
5 - Realizar o produto cartesiano sobre essa lista e gerar uma lista de tuplas.
6 - Tranformar tuplas em strings fazendo a concatenação do primeiro nome e do sobrenome.

Percebe-se que cada passo acima realiza uma única ação, sendo ela simples e clara e é interessante modelar cada um desses passos como uma função.
Na linguagem Haskell o tipos dos argumentos e do retorno de uma função é dado pela notação nomeDaFuncao :: arg1 -> arg2 -> ... -> retorno, onde arg1 e arg2 definem os tipos dos argumentos \cite{lipovaca}.
Para identificar listas em Haskell é usado o símbolo [], ou seja [Char] indica uma lista de carácteres e tuplas são indicatas com () onde (String, String) indica uma tupla com dois elementos, ambos strings.
Podemos agora reescrever o problema acima definindo todas as funções que serão utilizadas.

Primeiramente definiremos o problema enunciado como uma função usando a notação introduzida.
O problema inicial é uma função $combinarNomes :: [String] -> [String]$ , ou seja uma função que recebe uma lista de Strings e retorna uma lista de Strings.
Em seguida, iremos declarar a função que representa cada passo acima.

1 - separarNomes :: [String] -> [[String]]
2 - tirarIncompleto :: [[String]] -> [[String]]
3 - removerSobrenomes :: [[String]] -> [[String]]
4 - gerarNomesESobrenomes :: [[String]] -> ([String], [String])
5 - gerarCombinacoes :: ([String], [String]) -> [(String, String)]
6 - concatenarNomes :: [(String, String)] -> [String]


O algoritimo de ordenação conhecido como \emph{merge sort} aplica o paradigma de dividir e conquistar.
Segundo \cite{Cormen}, esse método consiste basicamente de quebrar o problema inicial em subproblemas menores, resolver os subproblemas recurssivamente e combinar essas soluções para resolver o problema original.
Segundo \cite{Cormen}, podemos aplicar esse paradigma para resolver o problema de ordernar uma sequencia de $n$ elementos da seguinte maneira.
\begin{cite}
Dividir: Divida a sequencia a ser ordernada em duas sequencias com $n/2$ elementos em cada.
Conquistar: Ordene as duas subsequencias de maneira recurssiva usando o \emph{merge sort}.
Combinar: Combine as duas subsequencias ordernadas para resolver o problema.
\end{cite}

Dado essa sequencia de passos, podemos definir uma maneira funcional de resolver esse problema.
Suponha uma função mergeSort que recebe uma lista (ordenada ou não) de valores como argumento e retorna essa mesma lista ordenada, por conveniência uma lista de valores será indicada pela notação [a].
Segundo o algoritimo proposto, a função mergeSort divide a lista [a] em duas listas e às ordena, ou seja a função mergeSort chama ela própria (por isso recurssão).
Então primeiramente, a lista [a] é transformada em duas listas.
Pode-se definir uma condição de fronteira para o problema de ordenação em que uma lista com um único elemento é dita ordenada, apos terminar a recursão teremos n listas ordenadas.
A proxima transformação é como combinar duas listas ordenadas a fim de produzir uma lista ordenada.

O problema de combinar duas listas ordenadas é por sua vez um diferente problema computacional.
Suponha agora uma função mergeLists que recebe duas listas ordernas e retorna uma lista ordenada.
Sabendo que ambas as lista são ordenadas, podemos identificar qual deve ser o primeiro elemento da união de listas, ou seja, qual o menor elemento de ambas as listas, remover esse elemento da lista correspondente e em seguida, criar uma nova lista com esse elemento como primeiro e concatenar a essas lista o retorno da função mergeLists nas duas listas depois de alteração.
A aplição recursiva da função mergeList irá sempre identificar o menor elemento das duas listas, extrair esse elemento e aplicar ela mesma nas listas resultantes.
Esse procedimento se repete até que uma das listas esteja vazia, pois nesse momento teremos uma lista ordenada devido a condição inicial do mergeLists.

%%%%%%%%%%%%%%BREAK

Embora existam varias linguagens funcionais (ML, Lisp, Rackett, Haskell), todas elas compartilham essa origem.

Tal como em programacao imperativa que diferencia linguagens entre procedural e orientada a objetos, existem diferencas entre as linguagens funcionais, mas primeiramente, o que eh programacao funcional.

Esse trabalho foca na linguagem Haskell como fonte de exemplos para o paradigma funcional.
Haskell, como toda linguagem, possui suas proprias particularidades, porem grande partes dos conceitos apresentados sera geral para linguagens funcionais.

Haskell faz parte do conjunto de linguagens conhecidas como "linguagens funcionais puras".
Uma linguagem pura permite a \emph{definicao} de simbolos uma unica vez, exemplo, ao definir "let a = 4" em um programa, tentar mudar o valor da variavel "a" resulta em um error.
O valor de um simbolo nao pode mudar durante a execucao do programa, de certa forma isso eh equivalente as keywords "final" do java e "const" da linguagem C.
Embora nao poder atualizar o valor de uma variavel soe como uma grande desvantagem, isso permite o que pode ser chamado de "funcoes sem efeito-colateral".
Isso significa que uma funcao jamais ira alterar o estado do programa fora dela, toda vez que uma funcao for chamada com os mesmos atributos, ela ira retornar o mesmo valor, isso nao eh o caso em linguagens orientadas a objeto, por exemplo, onde metodos alteram o estado do objeto (setters).
O conceito de funcoes sem efeito colateral eh uma vantagem pois isso facilita o entendimento do programador sobre a sequencia de eventos do programa, nao existe preucupacao de que uma funcao altere alguma variavel global ou o estado de um objeto.
Lipovaca expressa o conceito de linguagem funcional pura de maneira instrutiva, ele diz que:
"Embora isso parece limitante quando voce esta vindo do mundo imperativo, nos vimos que isso eh algo realmente legal. Em uma linguagem imperativa voce nao tem garantia de que uma simples funcao que deveria somente processar alguns numeros nao ira queimar sua casa, sequestrar seu cachorro e riscar seu carro com uma batata enquanto processa aqueles numeros.".

Como nao podemos alterar o estado de uma variavel em um programa funcional, isso nos forca a procurar diferentes maneiras de resolver problemas computacionais.
Um exemplo classico disso eh o problema de calcular o fatorial de um numero.
O fatorial de n (n!) eh definido como $ n! = (1)*(2)*...*(n-1)*(n)$.
Em uma linguagem imperativa, esse problema pode ser resolvido com um for, uma variavel acumuladora e uma variavel contadora; como nao podemos mutar o valor de definicoes em linguagens funcionais, podemos fazer usso de recurssao.

O programa abaixo define uma funcao "factorial" que recebe um valor do tipo int retorna um de valor int.
A funcao "factorial" retorna o valor 1 quando seu argumento eh 0 e retorna o valor n * (n-1)! para qualquer outro valor.
Essas curiosa sintaxe faz uso de um construtor muti util do Haskell chamado de \emph{patten matching}.
Segundo \ref{lipovaca}, "pattern matching consiste de especificar padroes para o qual algum dado deve tomar forma, verificar se o dado acorda com esses padroes", eh possivel definir varios padroes para uma unica funcao.
Padroes sao executados de cima para baixo e por isso padroes mais gerais (dao match em um maior numero de situacoes) devem ser posicionados por ultimo.

factorial :: Int -> Int
factorial 1 = 1
factorial n = n * factorial (n-1)

Tipos de dados diferentes possuem diferentes possibilidades de pattern matching.
Em Haskell, valores contidos dentro de colchetes "[]" define uma lista, e o padrao (x:xs) define que x eh o primeiro elemento da lista e xs o restante da lista.
Por exemplo, dado a lista [1,2,3] os valores de (x:xs) em um pattern matching tera o valor de x = 1 e xs = [2,3].
Usando esse construtor, podemos definir a funcao sum que soma todos os numero em uma lista.

sum :: [Int] -> Int
sum [] = 0
sum (x:xs) = x + sum xs

O codigo acima define uma funcao sum que recebe uma lista de ints ("[Int]") e retorna um int, a funcao sum faz uso de dois pattern matchings.
O primeiro padrao "[]" faz match com uma lista vazia, o valor da funcao sum para a lista vazia eh definido como o valor 0.
Caso a lista nao seja vazia, o segundo padrao eh executado, e para aquele caso a soma de uma lista eh definida como o primeiro elemento mais a soma do restante da lista.
Novamente, isso eh uma funcao que faz uso de recursao para resolver o problema computacional.
A funcao sum chama a ela mesma ate o valor de xs ser a lista vazia, para o qual definimos que isso seria igual a $0$.
Caso omitissimos o primeiro padrao, a funcao iria chamar a ela mesma indefinitvamente.
Pattern matching eh muito util em funcoes recursivas pois nos permite definir a condicao de saida da recurssao.

\subsubsection{Algoritimos de regex}

Nessa secao sera abordado um pouco sobre maquinas de estado, como elas podem ser usadas para representar expressoes regulares.
Talvez abordar a diferenca entre maquinas deterministicas e nao deterministicas, e como uma maquina nao deterministica pode ser transformada em deterministica.

Ainda estou em duvida qual algoritimo sera utilizado para a construcao da biblioteca, irei pesquisar mais sobre isso.

\subsection{METODOLOGIA}

Utilizando os algoritimos abordados na secao de algoritimos, sera criado um modulo escrito funcionalmente em Haskell para realizar a pesquisa de regexes em um texto.

Tenho duvida a respieto dessa secao. O que faz parte do escopo de metodologia?
Praticas de desenvolvimento aplicadas como testes unitarios?

Acredito que a maior parte do conteudo abordado aqui seja estabelecido apos a escolha do algoritmo(s) de regex a serem implementados.

A definicao do dialeto da regex, junto dos simbolos especiais, flags e etc deve ser feita nessa secao ou na fundamentacao teorica?


